# 小冰美化助手 - 编辑策略规范

## 版本信息

- **规范版本**: 1.1.0
- **程序版本**: 3.0.0
- **编辑日期**: 2025-12-14
- **作者**: 小冰美化助手团队

### 更新说明 (v1.1.0)
- 重构渲染配置结构：从对象改为数组，每个配置对应一个独立输出文件
- 添加输出路径和文件名模板支持
- 每个渲染配置支持独立的图层选择和平铺设置
- 增强了批量处理工具的功能
- 重构滤镜系统：支持通用滤镜列表和智能对象滤镜

## 概述

编辑策略是嵌入在 Photoshop PSD 文件 XMP 元数据中的 JSON 配置，用于定义对该 PSD 文件的批量编辑和渲染规则。策略支持：

- 按顺序执行的编辑操作队列
- 多套渲染配置（支持多种输出格式和参数）
- 基于图层名称路径的定位（而非脆弱的图层ID）
- 表格数据驱动的批量替换

## 存储位置

策略配置存储在 PSD 文件的 XMP 元数据中，使用命名空间 `photoshop:edit_strategy`。

### XMP 结构

```xml
<?xpacket begin="" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 7.1-c000 79.9e4d4e6, 2022/06/30-20:37:39">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/">
         <photoshop:edit_strategy>
           {
             "version": "1.1.0",
             "created": "2025-12-14T12:00:00Z",
             "modified": "2025-12-14T12:00:00Z",
             ... 策略内容 ...
           }
         </photoshop:edit_strategy>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
<?xpacket end="w"?>
```

### 程序接口

#### Python 服务器接口

```python
from ps_server import get_server

server = get_server()

# 读取XMP元数据
async def on_xmp_read(metadata, error):
    if error:
        print(f"读取失败: {error}")
    else:
        print(f"读取成功，数据长度: {len(metadata)}")

req_id = await server.read_xmp_metadata(callback=on_xmp_read)

# 写入XMP元数据
xmp_xml = create_xmp_xml(json.dumps(strategy))

async def on_xmp_write(success, error):
    if success:
        print("写入成功")
    else:
        print(f"写入失败: {error}")

req_id = await server.write_xmp_metadata(xmp_xml, callback=on_xmp_write)
```

#### JavaScript 插件接口

程序自动处理 XMP 读写，无需手动调用 JavaScript 接口。

### 读取流程

1. 程序调用 `server.read_xmp_metadata()`
2. 服务器发送 `read_xmp` 消息给插件
3. 插件使用 Action Manager 读取 `XMPMetadataAsUTF8` 属性
4. 返回完整的 XMP XML 字符串
5. 程序解析 XML 提取 `photoshop:edit_strategy` 内容

### 写入流程

1. 程序生成包含策略的完整 XMP XML
2. 调用 `server.write_xmp_metadata(xmp_xml)`
3. 服务器发送 `write_xmp` 消息给插件
4. 插件使用 Action Manager 设置 `XMPMetadataAsUTF8` 属性
5. 对于已保存的文档，自动执行保存操作以应用更改
6. 对于新建文档，跳过保存步骤（需要用户手动保存）

### 注意事项

- XMP 数据存储在文件头部，不影响图像数据
- 读取操作不会修改原文件
- **写入操作会修改PSD文件，需要用户确认保存**
- 对于新建文档，XMP数据已设置但需要手动保存才能持久化
- 支持 Unicode 字符，但需要正确转义XML特殊字符

### 注意事项

- XMP 数据存储在文件头部，不影响图像数据
- 读取操作不会修改原文件
- 写入操作会修改PSD文件，需要用户确认保存
- 支持 Unicode 字符，但需要正确转义XML特殊字符
- XMP 数据有大小限制，建议保持策略简洁

## JSON 格式规范

### 根级结构

```json
{
  "version": "1.0.0",
  "created": "2025-12-14T12:00:00Z",
  "modified": "2025-12-14T12:00:00Z",
  "description": "策略描述（可选）",
  "author": "作者信息（可选）",
  "operations": [...],
  "renders": [...]
}
```

### 字段说明

| 字段 | 类型 | 必需 | 描述 |
|------|------|------|------|
| `version` | string | 是 | 策略格式版本号 |
| `created` | string | 是 | 创建时间（ISO 8601格式） |
| `modified` | string | 是 | 最后修改时间（ISO 8601格式） |
| `description` | string | 否 | 策略描述 |
| `author` | string | 否 | 作者信息 |
| `operations` | array | 是 | 编辑操作队列 |
| `renders` | array | 是 | 渲染配置列表，每个配置对应一个输出文件 |

## 编辑操作队列

### 操作类型

#### 1. 更新文本图层 (update_text_layer)

```json
{
  "type": "update_text_layer",
  "target_path": "主文档 > 标题层",
  "text": "新的文本内容",
  "group": 1,  // 可选：从数据表格的第 1 列获取值
  "regex_steps": [  // 可选：对文本内容进行多步正则处理
    {
      "name": "前面加@",
      "find": "^",
      "replace": "@"
    }
  ]
}
```

**参数说明**：
- `target_path`: 图层名称路径，使用 `>` 分隔，支持智能对象嵌套
- `text`: 新文本内容（如果指定 `group`，此值会被覆盖）
- `group`: 可选，从数据表格的对应列索引获取值（从 1 开始的整数）
- `regex_steps`: 可选，一个包含多步正则表达式处理的数组。每步包含：
  - `name`: 处理步骤的名称（仅用于 UI 展示）
  - `find`: 正则查找模式（字符串形式，注意转义）
  - `replace`: 替换字符串（支持正则捕获组，如 `$1`）

**处理流程**：
1. 如果指定了 `group`，先从数据表获取对应文本。
2. 如果指定了 `text` 且没有 `group`，使用该文本。
3. 如果指定了 `regex_steps`，按数组顺序依次对文本应用正则替换。
4. 将最终处理后的文本发送至 Photoshop。

#### 2. 替换智能对象图片 (replace_image)

```json
{
  "type": "replace_image",
  "target_path": "主文档 > 智能对象A > 图片层",
  "image_path": "C:/images/photo.jpg",
  "group": 2  // 可选：从数据表格的第 2 列获取图片路径
}
```

**参数说明**：
- `target_path`: 智能对象图层的名称路径
- `image_path`: 图片文件路径
- `group`: 可选，从数据表格的对应列索引获取图片路径（从 1 开始的整数）

#### 3. 批量操作 (batch_play)

```json
{
  "type": "batch_play",
  "target_path": "主文档 > 图层组",  // 可选：操作目标路径
  "descriptors": [
    {
      "_obj": "set",
      "_target": [{"_ref": "layer", "_enum": "ordinal", "_value": "targetEnum"}],
      "to": {"_obj": "layer", "opacity": {"_unit": "percentUnit", "_value": 50}}
    }
  ]
}
```

**参数说明**：
- `target_path`: 可选，操作目标的图层路径
- `descriptors`: Photoshop Action Descriptor 数组

#### 4. 应用滤镜 (apply_filter)

```json
{
  "type": "apply_filter",
  "target_path": "主文档 > 智能对象A",
  "filter_type": "emboss",
  "params": {
    "angle": 135,
    "height": 2,
    "amount": 100
  }
}
```

**参数说明**：
- `target_path`: 目标图层路径。
- `filter_type`: 滤镜类型，目前支持 `emboss` (浮雕)。
- `params`: 滤镜参数字典。

### 操作执行顺序

操作按数组顺序严格执行：
1. **更新文本/图片**: `update_text_layer`, `replace_image`
2. **应用智能对象滤镜**: `apply_filter`
3. **执行 BatchPlay**: `batch_play`

同类操作之间没有严格顺序，但建议按上述逻辑分类组织以获得最佳性能。

## 渲染配置

### 渲染套装结构

渲染配置现在支持为每个输出文件定义独立的渲染参数，每个配置是一个独立的字典：

```json
{
  "renders": [
    {
      "name": "web_jpg_designAB",
      "description": "网页用JPG版本（设计A+B）",
      "output_path": "./output/web",
      "filename": "design_{index}",
      "format": "jpg",
      "quality": 85,
      "root_layers": ["主文档 > 设计A", "主文档 > 设计B"],
      "tiling": {
        "enabled": false
      }
    },
    {
      "name": "web_png_designABC",
      "description": "网页用PNG版本（设计A+B+C）",
      "output_path": "./output/web",
      "filename": "design_full_{index}",
      "format": "png",
      "quality": 100,
      "root_layers": ["主文档 > 设计A", "主文档 > 设计B", "主文档 > 设计C"],
      "tiling": {
        "enabled": false
      }
    },
    {
      "name": "print_tiff_designA",
      "description": "打印用TIFF版本（设计A）",
      "output_path": "./output/print",
      "filename": "print_designA_{index}",
      "format": "tiff",
      "quality": 100,
      "root_layers": ["主文档 > 设计A"],
      "tiling": {
        "enabled": true,
        "width": 2100,
        "height": 2970,
        "ppi": 300
      },
      "filters": []
    },
    {
      "name": "web_jpg_embossed",
      "description": "网页用JPG版本（带浮雕效果）",
      "output_path": "./output/web",
      "filename": "design_embossed_{index}",
      "format": "jpg",
      "quality": 85,
      "root_layers": ["主文档 > 设计A", "主文档 > 设计B"],
      "tiling": {
        "enabled": false
      },
      "filters": [
        {
          "type": "emboss",
          "params": {
            "angle": 135,
            "height": 2,
            "amount": 100
          }
        }
      ]
    }
  ]
}
```

### 渲染配置参数说明

每个渲染配置都是一个独立的字典，包含以下参数：

#### 基本参数

| 参数 | 类型 | 必需 | 描述 |
|------|------|------|------|
| `name` | string | 是 | 配置名称，用于标识和引用 |
| `description` | string | 否 | 配置描述 |
| `output_path` | string | 是 | 输出目录路径 |
| `filename` | string | 是 | 输出文件名模板，支持 `{index}` 占位符 |
| `format` | string | 是 | 输出格式（jpg/png/gif/webp/tiff/psd） |
| `quality` | number | 否 | 图像质量（0-100），仅对有损格式有效 |
| `root_layers` | array | 否 | 要渲染的根图层路径列表，不指定则渲染全部 |

#### 平铺参数 (tiling)

| 参数 | 类型 | 必需 | 描述 |
|------|------|------|------|
| `enabled` | boolean | 是 | 是否启用平铺 |
| `width` | number | 否 | 画布宽度（像素），启用平铺时必需 |
| `height` | number | 否 | 画布高度（像素），启用平铺时必需 |
| `ppi` | number | 否 | 分辨率（像素/英寸），默认 300 |

#### 滤镜参数 (filters)

`filters` 是一个数组，包含要按顺序应用的滤镜配置：

| 参数 | 类型 | 必需 | 描述 |
|------|------|------|------|
| `type` | string | 是 | 滤镜类型（如 "emboss"） |
| `params` | object | 是 | 滤镜参数列表 |

**浮雕滤镜参数 (type: "emboss")**:

| 参数 | 类型 | 必需 | 描述 |
|------|------|------|------|
| `angle` | number | 否 | 浮雕角度（-180 到 180），默认 135 |
| `height` | number | 否 | 浮雕高度（1 到 100），默认 2 |
| `amount` | number | 否 | 浮雕数量（1% 到 500%），默认 100 |

### 支持的输出格式

每个渲染配置只支持一种输出格式：

- `jpg` / `jpeg`: JPEG 格式（支持质量设置）
- `png`: PNG 格式（透明支持，质量固定为100）
- `gif`: GIF 格式（质量固定为100）
- `webp`: WebP 格式（支持质量设置）
- `tiff` / `tif`: TIFF 格式（高质量，适合打印）
- `psd`: Photoshop PSD 格式（保留图层信息）

## 图层路径语法

### 路径格式

```
主文档 > 图层组A > 子图层B
主文档 > 智能对象A > 智能对象内部 > 文本层
```

### 规则

1. **分隔符**: 使用 `>` 分隔各级图层名称
2. **根标识**: 总是以 `主文档` 开头
3. **智能对象**: 智能对象作为路径节点，支持无限嵌套
4. **名称匹配**: 基于图层名称进行匹配，支持部分匹配和模糊搜索
5. **转义字符**: 如果图层名称包含 `>`，使用 `\|` 转义

### 示例

```json
// 简单的文本层替换
"operations": [
  {
    "type": "update_text_layer",
    "target_path": "主文档 > 标题",
    "group": 1
  }
]

// 智能对象图片替换
"operations": [
  {
    "type": "replace_image",
    "target_path": "主文档 > 产品展示 > 产品图片",
    "group": 2
  }
]

// 多层级智能对象
"operations": [
  {
    "type": "update_text_layer",
    "target_path": "主文档 > 智能对象A > 智能对象B > 副标题",
    "group": 3
  }
]
```

## 数据表格格式

### 支持格式

- CSV (逗号分隔)
- Excel (xlsx)
- JSON 数组

### CSV 示例 (不含表头)

```csv
"产品A标题","C:/images/product_a.jpg","产品A副标题","C:/images/product_a_main.jpg"
"产品B标题","C:/images/product_b.jpg","产品B副标题","C:/images/product_b_main.jpg"
```

### JSON 示例 (行数据使用索引字符串作为键)

```json
[
  {
    "1": "产品A标题",
    "2": "C:/images/product_a.jpg",
    "3": "产品A副标题",
    "4": "C:/images/product_a_main.jpg"
  }
]
```

### 表格字段映射

策略中的 `group` 参数指定从表格的哪一列（从 1 开始）获取数据：

```json
{
  "type": "update_text_layer",
  "target_path": "主文档 > 标题",
  "group": 1  // 从表格的第 1 列获取值
}
```

**注意：**
1. 批量处理时将**忽略表头**，直接按列顺序读取。
2. 多个操作可以指向同一个 `group`，实现一改全改。
3. UI 会根据策略中所有唯一的 `group` 索引生成对应的输入项提示。

## 完整示例

```json
{
  "version": "1.0.0",
  "created": "2025-12-14T10:00:00Z",
  "modified": "2025-12-14T10:00:00Z",
  "description": "电商产品海报批量制作策略",
  "author": "设计师小明",
  "operations": [
    {
      "type": "update_text_layer",
      "target_path": "主文档 > 产品标题",
      "group": 1
    },
    {
      "type": "update_text_layer",
      "target_path": "主文档 > 产品副标题",
      "group": 2
    },
    {
      "type": "replace_image",
      "target_path": "主文档 > 产品图片",
      "group": 3
    },
    {
      "type": "update_text_layer",
      "target_path": "主文档 > 价格标签",
      "group": 4
    }
  ],
  "renders": [
    {
      "name": "web_jpg_basic",
      "description": "网页用JPG版本（标题+副标题）",
      "output_path": "./output/web",
      "filename": "product_{index}_basic",
      "format": "jpg",
      "quality": 85,
      "root_layers": ["主文档 > 产品标题", "主文档 > 产品副标题"],
      "tiling": {
        "enabled": false
      },
      "filters": []
    },
    {
      "name": "web_png_full",
      "description": "网页用PNG版本（完整设计）",
      "output_path": "./output/web",
      "filename": "product_{index}_full",
      "format": "png",
      "quality": 100,
      "root_layers": ["主文档 > 产品标题", "主文档 > 产品副标题", "主文档 > 产品图片", "主文档 > 价格标签"],
      "tiling": {
        "enabled": false
      },
      "filters": []
    },
    {
      "name": "print_tiff_a4",
      "description": "打印用TIFF版本（A4尺寸）",
      "output_path": "./output/print",
      "filename": "product_{index}_print",
      "format": "tiff",
      "quality": 100,
      "root_layers": ["主文档 > 产品标题", "主文档 > 产品副标题", "主文档 > 产品图片", "主文档 > 价格标签"],
      "tiling": {
        "enabled": true,
        "width": 2480,
        "height": 3508,
        "ppi": 300
      },
      "filters": []
    },
    {
      "name": "social_media_square",
      "description": "社交媒体用正方形版本",
      "output_path": "./output/social",
      "filename": "product_{index}_square",
      "format": "jpg",
      "quality": 90,
      "root_layers": ["主文档 > 产品图片", "主文档 > 产品标题"],
      "tiling": {
        "enabled": true,
        "width": 1200,
        "height": 1200,
        "ppi": 72
      },
      "filters": []
    },
    {
      "name": "print_tiff_embossed",
      "description": "打印用TIFF版本（带浮雕效果）",
      "output_path": "./output/print",
      "filename": "product_{index}_embossed",
      "format": "tiff",
      "quality": 100,
      "root_layers": ["主文档 > 产品标题", "主文档 > 产品副标题", "主文档 > 产品图片", "主文档 > 价格标签"],
      "tiling": {
        "enabled": false
      },
      "filters": [
        {
          "type": "emboss",
          "params": {
            "angle": 135,
            "height": 3,
            "amount": 120
          }
        }
      ]
    }
  ]
}
```

## 版本兼容性

### 版本号规则

- **MAJOR.MINOR.PATCH** 格式
- **MAJOR**: 不兼容的格式变更
- **MINOR**: 向下兼容的新功能
- **PATCH**: 向下兼容的修复

### 版本兼容性保证

- 程序支持读取低版本策略
- 高版本策略可能包含低版本不支持的功能
- 程序会提示版本兼容性警告

## 扩展性设计

### 预留字段

策略中可以包含程序未识别的字段，这些字段会被安全忽略，为未来功能扩展留出空间。

### 自定义操作类型

程序支持加载自定义操作插件，实现特定领域的批量操作。

### 多语言支持

路径中的图层名称支持 Unicode，允许中英文混合使用。

## 最佳实践

### 1. 图层命名规范

- 使用有意义的英文或中文名称
- 避免使用特殊字符，可能影响路径解析
- 对于需要批量操作的图层，使用一致的命名模式

### 2. 策略组织

- 为不同用途创建不同的策略
- 使用 `description` 字段详细说明策略用途
- 定期更新 `modified` 时间戳

### 3. 性能考虑

- 避免过度嵌套的智能对象路径
- 合理安排操作顺序，减少重复的智能对象切换
- 对于大量数据，使用高效的数据表格格式

### 4. 错误处理

- 策略中包含路径不存在的图层时，程序会跳过该操作并记录警告
- 图片文件不存在时，程序会尝试继续处理其他操作
- 所有错误都会记录到日志中，便于调试

### 5. 浮雕滤镜使用建议

- 浮雕滤镜在最终叠加好可见层后应用，适合用于：
  - 为最终输出添加立体效果
  - 增强设计作品的视觉层次
  - 创建特殊的艺术效果
- 建议参数设置：
  - **角度（angle）**：135° 适合大多数情况，可根据光源方向调整
  - **高度（height）**：1-3 像素适合精细效果，3-10 像素适合明显效果
  - **数量（amount）**：100% 为标准效果，可根据需要调整到 50%-200%
- 注意事项：
  - 浮雕滤镜会应用到合并后的整体图层，无法单独撤销
  - 建议在应用前先保存原文件或使用副本
  - 对于需要保留图层信息的 PSD 格式，浮雕效果会应用到合并后的图层

## 策略执行功能

### 当前支持的功能

程序目前支持以下策略相关功能：

#### 1. 策略读写
- ✅ **读取策略**：从 PSD 文件的 XMP 元数据中读取编辑策略
- ✅ **写入策略**：将编辑策略保存到 PSD 文件的 XMP 元数据中
- ✅ **策略解析**：自动解析 JSON 格式的策略配置

#### 2. 操作执行
- ✅ **顺序执行操作队列**：支持按顺序执行 `operations` 数组中的操作
- ✅ **支持的操作类型**：
  - `update_text_layer`：更新文本图层
  - `replace_image`：替换智能对象图片
  - `apply_filter`：应用智能对象滤镜 ✨ 新增
  - `batch_play`：执行 Photoshop Action Descriptor 批量操作

#### 3. 渲染输出
- ✅ **多配置渲染**：支持根据 `renders` 数组中的多个配置进行渲染
- ✅ **渲染参数支持**：
  - 图层选择（`root_layers`）
  - 平铺设置（`tiling`）
  - **多重滤镜（`filters`）** ✨ 重构
  - 输出格式和质量设置

### 功能限制

#### 当前不支持的功能
- ❌ **图层路径解析**：策略中使用 `target_path`（图层名称路径），但执行时需要 `layer_id`
  - 需要额外的图层路径到 ID 的转换功能
  - 建议：先获取图层结构，然后根据路径匹配找到对应的图层 ID
- ❌ **数据表格驱动**：策略中定义的 `group` 参数（从数据表格列索引获取值）需要额外的批量处理工具支持
- ❌ **策略验证器**：自动验证策略格式和图层路径有效性的工具

#### 建议的实现方式

要完整实现策略执行功能，需要：

1. **图层路径解析器**：
   ```python
   def resolve_layer_path(layer_tree, target_path):
       """将图层路径（如"主文档 > 标题层"）转换为图层ID和parent_chain"""
       # 实现路径解析逻辑
       return layer_id, parent_chain
   ```

2. **批量处理工具**：
   ```python
   async def execute_strategy_with_data(strategy, data_table):
       """根据策略和数据表格批量执行操作"""
       for row in data_table:
           # 解析策略中的 group 参数
           # 执行操作队列
           # 执行渲染配置
   ```

3. **策略执行器**：
   ```python
   async def execute_strategy(strategy):
       """执行完整的编辑策略"""
       # 1. 获取图层结构
       layer_tree = await server.request_layers()
       
       # 2. 解析操作中的 target_path
       operations = []
       for op in strategy["operations"]:
           layer_id, parent_chain = resolve_layer_path(layer_tree, op["target_path"])
           operations.append({
               "type": op["type"],
               "layer_id": layer_id,
               "parent_chain": parent_chain,
               # ... 其他参数
           })
       
       # 3. 执行操作队列
       await server.execute_operations_sequentially(operations)
       
       # 4. 执行渲染配置
       for render_config in strategy["renders"]:
           await server.render_output(
               output_folder=render_config["output_path"],
               file_name=render_config["filename"],
               format=render_config["format"],
               root_ids=resolve_root_layers(layer_tree, render_config["root_layers"]),
               tiling=render_config["tiling"]["enabled"],
               output_width=render_config["tiling"].get("width", 0),
               output_height=render_config["tiling"].get("height", 0),
               filters=render_config.get("filters", [])
           )
   ```

## 工具支持

### 策略编辑器

程序提供可视化的策略编辑器，支持：

- 拖拽选择图层生成路径
- 预览操作效果
- 验证策略格式
- 导入/导出策略配置

### 批量处理工具

- 支持选择数据表格文件
- 实时预览替换效果
- 根据策略中的渲染配置批量导出多个版本
- 进度显示和错误报告
- 支持选择执行特定的渲染配置

### 策略管理器

- 列出PSD文件中包含的策略
- 编辑现有策略
- 策略版本管理
- 策略模板库

### XMP 工具

#### 读取策略

从当前打开的PSD文件中读取编辑策略：

```python
# 读取并解析策略
metadata = await server.read_xmp_metadata()
if metadata:
    strategy = parse_strategy_from_xmp(metadata)
```

#### 保存策略

将编辑策略保存到PSD文件的XMP元数据中：

```python
# 生成XMP并保存
xmp_xml = create_xmp_xml(json.dumps(strategy))
success = await server.write_xmp_metadata(xmp_xml)
```

#### 策略验证

程序会自动验证策略格式，包括：
- JSON 语法正确性
- 必需字段完整性
- 图层路径有效性
- 渲染配置合理性
